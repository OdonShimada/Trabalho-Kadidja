import random


# -------------------------------
# ğŸ° MENU PRINCIPAL
# -------------------------------
"""

O **Menu Principal** foi criado para organizar a navegaÃ§Ã£o entre os diferentes jogos e funÃ§Ãµes do cassino.

Aqui centralizamos tudo que o jogador pode fazer no sistema:
- Escolher entre os jogos disponÃ­veis (21, Dados e Roleta)
- Verificar o saldo atual
- Fazer depÃ³sitos
- Encerrar o jogo (sair)

A ideia Ã© oferecer uma interface simples, intuitiva e interativa,
permitindo que o jogador tenha controle total sobre sua experiÃªncia no cassino.
AlÃ©m disso, em qualquer momento dentro dos jogos ou menus, existe a opÃ§Ã£o de voltar para o menu principal,
garantindo que o jogador nÃ£o fique preso em nenhuma etapa.

Isso permite uma navegaÃ§Ã£o clara, segura e eficiente,
mantendo a organizaÃ§Ã£o do cÃ³digo e facilitando futuras atualizaÃ§Ãµes ou inclusÃ£o de novos jogos.

"""

def main():
    saldo_inicial = float(input("Informe o saldo inicial: R$ "))
    jogos = {
        1: VinteUm(saldo_inicial),
        2: Dados(saldo_inicial),
        3: Roleta(saldo_inicial),
        4: ParOuImpar(saldo_inicial)  # Jogo adicionado aqui
    }

    while True:
        print("\nğŸ° --- MENU DE JOGOS ---")
        print("1 - Jogar 21 (Vinte e Um)")
        print("2 - Jogar Dados")
        print("3 - Jogar Roleta")
        print("4 - Jogar Par ou Ãmpar")  # OpÃ§Ã£o adicionada
        print("5 - Verificar saldo")
        print("6 - Depositar")
        print("7 - Sair")

        escolha = input("Escolha uma opÃ§Ã£o: ")

        if escolha == '1':
            jogos[1].menu()
        elif escolha == '2':
            jogos[2].menu()
        elif escolha == '3':
            jogos[3].menu()
        elif escolha == '4':
            jogos[4].menu()  # Chama o menu de Par ou Ãmpar
        elif escolha == '5':
            jogos[1].verificar_saldo()
        elif escolha == '6':
            realizar_deposito(jogos)
        elif escolha == '7':
            print("ğŸ‘‹ Saindo... Obrigado por jogar!")
            break
        else:
            print("OpÃ§Ã£o invÃ¡lida.")


def realizar_deposito(jogos):
    valor = input("Valor para depÃ³sito (ou 'M' para Menu): ").upper()
    if valor == 'M':
        return
    try:
        valor = float(valor)
        if valor > 0:
            for jogo in jogos.values():
                jogo.depositar(valor)
            print("ğŸ’¸ DepÃ³sito realizado com sucesso!")
        else:
            print("Valor invÃ¡lido.")
    except ValueError:
        print("Valor invÃ¡lido.")


# -------------------------------
# ğŸ¦ CLASSE BASE
# -------------------------------
"""

Classe base 'Jogo' criada para representar a estrutura comum de qualquer jogo de apostas.

Aqui centralizamos tudo relacionado ao controle de saldo do jogador:
- Depositar dinheiro
- Sacar dinheiro (caso tenha saldo suficiente)
- Ver o saldo atual

A ideia Ã© que todos os outros jogos herdem dessa classe pra nÃ£o ter cÃ³digo repetido
e pra manter um padrÃ£o. Com isso, dÃ¡ pra focar sÃ³ na lÃ³gica do jogo nas outras classes.

"""

class Jogo:
    def __init__(self, saldo_inicial=0):
        self._saldo = saldo_inicial

    def depositar(self, valor):
        if valor > 0:
            self._saldo += valor
        else:
            print("Valor de depÃ³sito invÃ¡lido.")

    def sacar(self, valor):
        if 0 < valor <= self._saldo:
            self._saldo -= valor
            return valor
        else:
            return 0

    def verificar_saldo(self):
        print(f"ğŸ’° Saldo atual: R${self._saldo:.2f}")
        return self._saldo


# -------------------------------
# ğŸƒ JOGO 21 (Vinte e Um)
# -------------------------------
"""

VersÃ£o simplificada do famoso jogo 21.

O jogador e a casa recebem valores aleatÃ³rios. Ganha quem chegar mais perto de 21 sem passar.
- Se o jogador passar de 21, perde automaticamente.
- Se a casa passar e o jogador nÃ£o, o jogador ganha.
- Se os dois ficarem abaixo de 21, vence quem tiver o maior valor.

TambÃ©m herda de 'Jogo' pra fazer toda a parte de saldo.
A ideia foi fazer uma lÃ³gica simples, sem cartas, sÃ³ com nÃºmeros.

"""

class VinteUm(Jogo):
    def __init__(self, saldo_inicial=0):
        super().__init__(saldo_inicial)

    def menu(self):
        while True:
            if self._saldo <= 0:
                print("âš ï¸ Seu saldo estÃ¡ zerado!")
                self.fazer_deposito()

            aposta = input("Digite o valor da aposta (ou 'M' para Menu): ").upper()
            if aposta == 'M':
                return
            try:
                aposta = float(aposta)
                if aposta <= 0:
                    print("Aposta invÃ¡lida.")
                    continue

                if aposta > self._saldo:
                    print("Saldo insuficiente para essa aposta.")
                    self.fazer_deposito()
                    continue

                self.jogar(aposta)
            except ValueError:
                print("Valor invÃ¡lido.")

            opcao = input("\nğŸ”„ Jogar novamente (S) ou ğŸ”™ Voltar ao menu (N)? ").upper()
            if opcao == 'N':
                break
            elif opcao != 'S':
                print("OpÃ§Ã£o invÃ¡lida. Retornando ao menu.")
                break

    def fazer_deposito(self):
        while True:
            valor = input("Digite o valor para depÃ³sito (ou 'M' para Menu): ").upper()
            if valor == 'M':
                return
            try:
                valor = float(valor)
                if valor > 0:
                    self.depositar(valor)
                    print("âœ… DepÃ³sito realizado.")
                    break
                else:
                    print("Valor invÃ¡lido.")
            except ValueError:
                print("Valor invÃ¡lido.")

    def jogar(self, aposta):
        self.sacar(aposta)

        print("\nğŸƒ Bem-vindo ao Vinte e Um! ğŸƒ")
        jogador = []
        dealer = []

        for _ in range(2):
            jogador.append(random.randint(1, 11))
            dealer.append(random.randint(1, 11))

        while True:
            print(f"\nSuas cartas: {jogador} | Total: {sum(jogador)}")
            print(f"Carta visÃ­vel do dealer: {dealer[0]}")

            if sum(jogador) == 21:
                print("ğŸ‰ VocÃª fez 21! VitÃ³ria garantida!")
                self.depositar(aposta * 2.5)
                return
            elif sum(jogador) > 21:
                print("ğŸ’¥ VocÃª estourou! Perdeu.")
                return

            escolha = input("Deseja (C)ontinuar, (P)arar ou (M)enu? ").upper()
            if escolha == 'C':
                jogador.append(random.randint(1, 11))
            elif escolha == 'P':
                break
            elif escolha == 'M':
                return
            else:
                print("Escolha invÃ¡lida.")

        print(f"\nCartas do dealer: {dealer} | Total: {sum(dealer)}")
        while sum(dealer) < 17:
            dealer.append(random.randint(1, 11))
            print(f"Dealer compra uma carta. Novas cartas: {dealer} | Total: {sum(dealer)}")

        total_jogador = sum(jogador)
        total_dealer = sum(dealer)

        if total_dealer > 21 or total_jogador > total_dealer:
            print("ğŸ‰ VocÃª venceu!")
            self.depositar(aposta * 2)
        elif total_jogador == total_dealer:
            print("ğŸ¤ Empate! VocÃª recupera sua aposta.")
            self.depositar(aposta)
        else:
            print("ğŸ˜” Dealer venceu. VocÃª perdeu.")


# -------------------------------
# ğŸ² JOGO DOS DADOS
# -------------------------------
"""

Simula um jogo de aposta com dados.

O jogador escolhe um nÃºmero entre 2 e 12 (soma de dois dados) e faz a aposta.
Dois dados sÃ£o lanÃ§ados (nÃºmeros aleatÃ³rios entre 1 e 6) e a soma define o resultado.
Se o jogador acertar o nÃºmero, ganha 6x o valor apostado (simula uma chance baixa com recompensa alta).

A lÃ³gica Ã© direta e usamos a classe Jogo pra controlar saldo.
Foi pensado pra testar sorte com uma chance mais difÃ­cil.

"""

class Dados(Jogo):
    def menu(self):
        while True:
            if self._saldo <= 0:
                print("âš ï¸ Seu saldo estÃ¡ zerado!")
                self.fazer_deposito()

            numero_apostado = input("Aposte em um nÃºmero entre 2 e 12 (ou 'M' para Menu): ").upper()
            if numero_apostado == 'M':
                return
            aposta = input("Digite o valor da aposta (ou 'M' para Menu): ").upper()
            if aposta == 'M':
                return
            try:
                numero_apostado = int(numero_apostado)
                aposta = float(aposta)

                if aposta <= 0 or aposta > self._saldo:
                    print("Aposta invÃ¡lida ou saldo insuficiente.")
                    self.fazer_deposito()
                    continue

                if not 2 <= numero_apostado <= 12:
                    print("NÃºmero fora do intervalo.")
                    continue

                self.jogar(numero_apostado, aposta)
            except ValueError:
                print("Valores invÃ¡lidos.")

            opcao = input("\nğŸ”„ Jogar novamente (S) ou ğŸ”™ Voltar ao menu (N)? ").upper()
            if opcao == 'N':
                break
            elif opcao != 'S':
                print("OpÃ§Ã£o invÃ¡lida. Retornando ao menu.")
                break

    def fazer_deposito(self):
        while True:
            valor = input("Digite o valor para depÃ³sito (ou 'M' para Menu): ").upper()
            if valor == 'M':
                return
            try:
                valor = float(valor)
                if valor > 0:
                    self.depositar(valor)
                    print("âœ… DepÃ³sito realizado.")
                    break
                else:
                    print("Valor invÃ¡lido.")
            except ValueError:
                print("Valor invÃ¡lido.")

    def jogar(self, numero_apostado, aposta):
        self.sacar(aposta)

        print("\nğŸ² --- Jogo dos Dados ---")
        d1 = random.randint(1, 6)
        d2 = random.randint(1, 6)
        soma = d1 + d2

        print(f"ğŸ² Dados: {d1} + {d2} = {soma}")

        if soma == numero_apostado:
            premio = aposta * 6
            print(f"ğŸ‰ ParabÃ©ns! VocÃª ganhou R$ {premio:.2f}")
            self.depositar(premio)
        else:
            print("ğŸ˜¢ VocÃª perdeu!")

        self.verificar_saldo()


# -------------------------------
# âœ‹ JOGO PAR OU ÃMPAR
# -------------------------------
"""
Jogo Par ou Ãmpar.

O jogador escolhe se quer par ou Ã­mpar e aposta um valor.
Dois nÃºmeros sÃ£o sorteados, somados, e a paridade define quem venceu.

Se o jogador acertar, ganha o valor apostado. Se errar, perde.
Jogo rÃ¡pido e com 50% de chance, simples pra testar as funÃ§Ãµes de aposta/saldo da classe base.

"""

class ParOuImpar(Jogo):
    def menu(self):
        while True:
            if self._saldo <= 0:
                print("âš ï¸ Seu saldo estÃ¡ zerado!")
                self.fazer_deposito()

            escolha = input("Escolha 'par' ou 'Ã­mpar' (ou 'M' para Menu): ").strip().lower()
            if escolha == 'm':
                return
            if escolha not in ['par', 'Ã­mpar']:
                print("Escolha invÃ¡lida.")
                continue

            aposta = input("Digite o valor da aposta (ou 'M' para Menu): ").upper()
            if aposta == 'M':
                return

            try:
                aposta = float(aposta)
                if aposta <= 0 or aposta > self._saldo:
                    print("Aposta invÃ¡lida ou saldo insuficiente.")
                    self.fazer_deposito()
                    continue

                self.jogar(escolha, aposta)
            except ValueError:
                print("Valor invÃ¡lido.")

            opcao = input("\nğŸ”„ Jogar novamente (S) ou ğŸ”™ Voltar ao menu (N)? ").upper()
            if opcao == 'N':
                break
            elif opcao != 'S':
                print("OpÃ§Ã£o invÃ¡lida. Retornando ao menu.")
                break

    def fazer_deposito(self):
        while True:
            valor = input("Digite o valor para depÃ³sito (ou 'M' para Menu): ").upper()
            if valor == 'M':
                return
            try:
                valor = float(valor)
                if valor > 0:
                    self.depositar(valor)
                    print("âœ… DepÃ³sito realizado.")
                    break
                else:
                    print("Valor invÃ¡lido.")
            except ValueError:
                print("Valor invÃ¡lido.")

    def jogar(self, escolha, aposta):
        self.sacar(aposta)

        print("\nâœ‹ --- Jogo Par ou Ãmpar ---")
        num1 = random.randint(1, 10)
        num2 = random.randint(1, 10)
        soma = num1 + num2
        resultado = 'par' if soma % 2 == 0 else 'Ã­mpar'

        print(f"NÃºmeros: {num1} + {num2} = {soma} ({resultado})")

        if escolha == resultado:
            print("ğŸ‰ VocÃª ganhou!")
            self.depositar(aposta * 2)
        else:
            print("ğŸ˜¢ VocÃª perdeu!")

        self.verificar_saldo()


# -------------------------------
# ğŸ¡ JOGO DA ROLETA
# -------------------------------
"""

Jogo da Roleta (simples).

O jogador escolhe entre vermelho ou preto, faz a aposta e a roleta "gira" (simulada com um nÃºmero aleatÃ³rio).
Dependendo do nÃºmero, associamos uma cor (par = vermelho, Ã­mpar = preto).
Se o jogador acertar a cor, ele ganha o dobro da aposta. Se errar, perde.

Usa a classe base Jogo pra lidar com o saldo do jogador.
A ideia Ã© simular a experiÃªncia de um cassino de forma bem simples.

"""

class Roleta(Jogo):
    def menu(self):
        while True:
            if self._saldo <= 0:
                print("âš ï¸ Seu saldo estÃ¡ zerado!")
                self.fazer_deposito()

            numero = input("Escolha um nÃºmero entre 0 e 36 (ou 'M' para Menu): ").upper()
            if numero == 'M':
                return
            valor = input("Valor da aposta (ou 'M' para Menu): ").upper()
            if valor == 'M':
                return

            try:
                numero = int(numero)
                valor = float(valor)

                if valor <= 0 or valor > self._saldo:
                    print("Aposta invÃ¡lida ou saldo insuficiente.")
                    self.fazer_deposito()
                    continue

                self.apostar(numero, valor)
            except ValueError:
                print("Valor invÃ¡lido.")

            opcao = input("\nğŸ”„ Jogar novamente (S) ou ğŸ”™ Voltar ao menu (N)? ").upper()
            if opcao == 'N':
                break
            elif opcao != 'S':
                print("OpÃ§Ã£o invÃ¡lida. Retornando ao menu.")
                break

    def fazer_deposito(self):
        while True:
            valor = input("Digite o valor para depÃ³sito (ou 'M' para Menu): ").upper()
            if valor == 'M':
                return
            try:
                valor = float(valor)
                if valor > 0:
                    self.depositar(valor)
                    print("âœ… DepÃ³sito realizado.")
                    break
                else:
                    print("Valor invÃ¡lido.")
            except ValueError:
                print("Valor invÃ¡lido.")

    def apostar(self, numero, valor):
        if numero < 0 or numero > 36:
            print("NÃºmero invÃ¡lido. Escolha entre 0 e 36.")
            return

        self.sacar(valor)

        print(f"Apostando R${valor:.2f} no nÃºmero {numero}... ğŸ¡ Girando a roleta!")
        resultado = random.randint(0, 36)
        print(f"NÃºmero sorteado: {resultado}")

        if resultado == numero:
            ganho = valor * 35
            print(f"ğŸ‰ ParabÃ©ns! VocÃª ganhou R${ganho:.2f}")
            self.depositar(ganho)
        else:
            print("ğŸ˜¢ VocÃª perdeu a aposta.")

        self.verificar_saldo()


# -------------------------------
# ğŸ”¥ EXECUTAR
# -------------------------------
if __name__ == "__main__":
    main()
